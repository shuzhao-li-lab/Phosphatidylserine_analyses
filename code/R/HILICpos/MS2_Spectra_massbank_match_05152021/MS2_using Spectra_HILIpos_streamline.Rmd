---
title: "MS2DDA_analysis_wt_Spectra_streamline_process"
author: "Minghao Gong"
date: "5/9/2021"
enhancement: filtering on retention time range & try on real tables.
output: html_document
---

```{r style, echo = FALSE, results = 'asis', message = FALSE}
rm(list=ls())
library(BiocStyle)
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

# Goal
- export all data to mgf format
- a simple matching of experimental MS2

## How to use
- Start docker using
  ```
  docker run \
    -e PASSWORD=bioc \
    -p 8787:8787 \
    -v /Users/gongm/Documents/projects/M420_Subrbier_CHIKV/M420_Suhrbier_CHIKV_04132021:/home/rstudio/external \
    spectra_xcms:latest
  ```
- or 
  ```
  bash /Users/gongm/Documents/projects/M420_Subrbier_CHIKV/M420_Suhrbier_CHIKV_04132021/analysis_0413run/code/docker_run_SpectraTutorial4_MS2analysis.sh
  ```
  
- Enter `http://localhost:8787` in a web browser and log in with username
  `rstudio` and password `bioc`.

# MS data import and handling
```{r}
getwd()
```


```{r}
output_dir1 = "../../../../output/MS2_out/HILICpos"
dir.create(output_dir1)
output_dir2 = "../../../../output/MS2_out/HILICpos/MS2_spectra_streamlined/"
dir.create(output_dir2)
output_dir = output_dir2
```

## Get the full path to the mzML files of HILICpos and load the data
```{r, results=TRUE}
path <- "../../../../../Raw_fromYating/mzML/HILICpos_DDA_exp" # without the final /

list.files(path, pattern = ".mzML")

#' Define the input files
fls <- paste0(path, "/", list.files(path, pattern = ".mzML"))
```


```{r, results=TRUE}
fls
```


```{r, load the files into object, results=TRUE}
library(Spectra)

#' Import the data
sps_all <- Spectra(fls, backend = MsBackendMzR())

```

## PrecursorMz intensity calculation
```{r read the same data using xcms and estimate precursor intensity}
od <- MSnbase::readMSData(fls, mode = "onDisk")
pints <- xcms::estimatePrecursorIntensity(od, ppm = 2)
```

```{r check if the spectra & MSn object matched}
# isTRUE(all.equal(rtime(od), rtime(sps_all)))
z = (rtime(od)==rtime(sps_all))
length(z[z ==FALSE]) #supposed to 0 and thus they are equal
```


```{r store the precursor Intensity back to sps subject}
sps_all$precursorIntensity <- pints
```

```{r}
sps_all$precursorIntensity[1:20]
```

```{r}
saveRDS(sps_all, file = paste0(output_dir,"sps_all_SpecObject_wt_PreInt.RDS")) 
# sps_all <- readRDS("stuff.RDS")
```


```{r}
#' List all available spectra variables (attributes)
spectraVariables(sps_all)
```

```{r in-mem-size}
print(object.size(sps_all), units = "MB")
```

### Check the DDA running procedure (Optional)
```{r}
sps_all$msLevel[1:40]
```


```{r}
sps_ms2 <- sps_all[sps_all$msLevel == 2]
print(
  paste0("spetra object number (in total): ", length(sps_all), "\n",
             "spetra object number (MS2): ",length(sps_ms2))
    )

saveRDS(sps_ms2, file = paste0(output_dir,"sps_ms2_SpecObject_wt_PreInt.RDS"))
```


```{r read sps_ms2 if needed}
if(TRUE) {
  sps_ms2 <- readRDS("../../../../output/MS2_out/HILICpos/MS2_spectra_streamlined/sps_ms2_SpecObject_wt_PreInt.RDS")
}
```



```{r}
# get a list of Features (r/t median and RT range)
# FT_test_df <- read.csv("../../../../input/test4MS2_streamline_analysis/featureDefinitions_subset4test.csv")
FT_test_df <- read.csv("../../../../input/test4MS2_streamline_analysis/JAXrun0413_first_analysis_outcome/sorted_filt_med_16.6_RawPval_0.05_FC_1.5_ttest_combined.csv")
FT_test_df
```


```{r}
precursor_candidate_l = FT_test_df$mzmed
rt_candidate_l = list()
for (i in (1:nrow(FT_test_df))) {
  rt_candidate_l[[i]] =  c(FT_test_df$rtmin[i], FT_test_df$rtmax[i])
}

```


```{r filter-precursor-mz}
#' Subset the dataset to MS2 spectra matching the m/z
sps_ms2based_on_pre_candid_l = list()
for (j in 1:length(precursor_candidate_l)) {
  mz <- precursor_candidate_l[j]
  sps_ms2based_on_pre_candid_l[[j]] <- filterPrecursorMz(sps_ms2, mz = mz + ppm(c(-mz, mz), 2))
  # print(j)
  rt_range <- rt_candidate_l[[j]]
  sps_ms2based_on_pre_candid_l[[j]] <- filterRt(sps_ms2based_on_pre_candid_l[[j]], rt = c(rt_range[1]-20,rt_range[2]+20))
  
}

```

```{r double-check how many groups of spectra associate with the precursorMz}
length(sps_ms2based_on_pre_candid_l)
```
```{r calculate how many spectra in each precursorMz}
sapply(sps_ms2based_on_pre_candid_l, function(x)length(x))
```


```{r}
sps_ms2based_on_pre_candid_l = sps_ms2based_on_pre_candid_l[sapply(sps_ms2based_on_pre_candid_l, function(x)length(x))!=0]
length(sps_ms2based_on_pre_candid_l)
sapply(sps_ms2based_on_pre_candid_l, function(x)length(x))
```

```{r Export the spectra of interest to a MGF file}
# Export the spectra of interest to a MGF file
output_dir_mgf <- paste0(output_dir, "spectra_mgf/")
dir.create(output_dir_mgf)
for (i in 1:length(sps_ms2based_on_pre_candid_l)) {
    export(sps_ms2based_on_pre_candid_l[[i]], backend = MsBackendMgf(), file =
             paste0(output_dir_mgf,
                    "sps_ms2_based_on_precursor_candidates_",
                    round(median(sps_ms2based_on_pre_candid_l[[i]]$precursorMz),4),
                    ".mgf"))
}
```


## Data processing and manipulation

### plot the spectra of candidate precursorMz, check if they are similar across RT.
```{r Plot the spectra, raw-ms2, fig.width = 7, fig.height = 7}
#' Plot the first spectrum
pdf(paste0(output_dir,"sps_ms2_based_on_inclusion_list.pdf"))
for (i in (1:length(sps_ms2based_on_pre_candid_l))) {
  if (length(sps_ms2based_on_pre_candid_l[[i]]) < 9) { # adjust the number if needed
    plot_num <- length(sps_ms2based_on_pre_candid_l[[i]]) } 
  else {
    plot_num <- 9 # adjust the number if needed
  }
  print(plot_num)
  plotSpectra(sps_ms2based_on_pre_candid_l[[i]][1:plot_num]) 
}
dev.off()

```


```{r filter-intensity}
#' Define a filtering function
low_int <- function(x, ...) {
    x > max(x, na.rm = TRUE) * 0.05
}
```


```{r filter-intensity}
#' Apply the function to filter the spectra
sps_ms2filt_norm_l = list()
if(TRUE) {
  for (i in (1:length(sps_ms2based_on_pre_candid_l))) {
    sps_ms2filt_norm_l[[i]] <- filterIntensity(sps_ms2based_on_pre_candid_l[[i]], intensity = low_int)
    
    # print(j)
    }
}


```

```{r raw-ms2-filtered, fig.width = 7, fig.height = 7}
#' Plot the first spectrum after filtering
plotSpectra(sps_ms2filt_norm_l[[11]][1:4])
```

```{r normalize}
#' Define a function to *normalize* the intensities
norm_int <- function(x, ...) {
    maxint <- max(x[, "intensity"], na.rm = TRUE)
    x[, "intensity"] <- 100 * x[, "intensity"] / maxint
    x
}
#' *Apply* the function to the data

if(TRUE) {
  for (i in (1:length(sps_ms2filt_norm_l))) {
    sps_ms2filt_norm_l[[i]] <- addProcessing(sps_ms2filt_norm_l[[i]], norm_int)
      
    # print(j)
    }
}
```

```{r}
#' Get the intensities after normalization
intensity(sps_ms2filt_norm_l[[i]])[[1]]
```


```{r reset if needed}
if(FALSE) {
  #' Remove any processing steps
  sps_orig <- reset(sps)
  head(intensity(sps_orig)[[1]])
}
```



## Spectrum data self-comparison (Optional)
- First stage only works on a single spectrum pack.
```{r compare-spectra-self, eval = FALSE}
#' Pairwise comparison of all spectra
cormat <- Spectra::compareSpectra(sps_ms2filt_norm_l[[2]], ppm = 1)
```

```{r ms2-heatmap, fig.width = 7, fig.height = 7, eval = FALSE}
library(pheatmap)
hm <- pheatmap(cormat)
```

```{r, eval = FALSE}
#' Get the cluster-assignment of the spectra
cl <- cutree(hm$tree_row, k = 5 , h = 0.5)
cl
```
```{r, eval = FALSE}
#' From which file are they?
if(FALSE) {
  split(basename(dataOrigin(sps_ms2filt_norm_l[[2]])), cl)
}
```


```{r, eval = FALSE}
#' precursorIntensity?
if(TRUE) {
  split(sps_ms2filt_norm_l[[2]]$precursorIntensity, cl)
}
```


```{r, eval = FALSE}
#' Are they have distinct retention time?
split(rtime(sps_ms2filt_norm_l[[2]]), cl)
```

```{r}
#' Select spectra from one collision energy
sps_select <- split(sps_ms2filt_norm_l[[2]], cutree(hm$tree_row, 5))[[1L]]
sps_select
```










## Select spectrum based on its top precursorIntensity

```{r}
sps_select_l = list()
for (i in (1:length(sps_ms2filt_norm_l))) {
  sps_ms2filt_norm_l[[i]]$precursorIntensity
  order_ind <- order(sps_ms2filt_norm_l[[i]]$precursorIntensity, decreasing = TRUE)
  retained_ind <- sapply(order_ind, function(x)if(x<=3){TRUE}else{FALSE})
  sps_select_l[[i]] <- sps_ms2filt_norm_l[[i]][retained_ind]
}

```


## Comparing spectra against MassBank
```{r massbank-library}
library(RMariaDB)
library(MsBackendMassbank)

#' Connect to the MassBank MySQL database
con <- dbConnect(MariaDB(), user = "massbank", dbname = "MassBank",
                 host = "localhost", pass = "massbank")
```

```{r massbank}
#' Access the spectra data in MassBank
mbank <- Spectra(con, source = MsBackendMassbankSql())
mbank
```

```{r massbank-size}
print(object.size(mbank), units = "MB")
```

```{r massbank-compare subset}


#' Identify spectra that contain a peak matching the precursorMz m/z of interest
res_l = list()
idx_l <- list()
sps_final_l <- list()
for (i in (1:length(sps_select_l))) { 
  has_mz <- containsMz(mbank, mz = mean(sps_select_l[[i]]$precursorMz), ppm = 10)
  mbank_with_mz <- mbank[has_mz]
  res_l[[i]] <- Spectra::compareSpectra(sps_select_l[[i]], mbank_with_mz, ppm = 5)
  
  if (is.null(nrow(res_l[[i]]))) {
    res_l[[i]] <- t(as.matrix(res_l[[i]]))
    colnames(res_l[[i]]) <- mbank_with_mz$spectrum_id

  }

  #' find the best one if it pass 0.7, else drop the loop
  if(max(res_l[[i]]) > 0.7) {
    idx_l[[i]] <- which(res_l[[i]] == max(res_l[[i]]), arr.ind = TRUE)
    print(idx_l[[i]])
    print(max(res_l[[i]]))
    #intensity(mbank_with_mz[idx[2]])

    #' *Normalize* the MassBank data
    mbank_with_mz <- addProcessing(mbank_with_mz, norm_int)

    #' Specifying a function to draw peak labels
    label_fun <- function(x) {
        ints <- unlist(intensity(x))
        mzs <- format(unlist(mz(x)), digits = 4)
        mzs[ints < 5] <- ""
        mzs
    }

    idx <- idx_l[[i]]
    sps_select <- sps_select_l[[i]]

    #' plot and export the best matching if passing dot-plot score > 0.7.
    pdf(paste0(output_dir,"mirror_plot_","JAX_1stDryAnal","_spsSelectMz_",sps_select[idx[1]]$precursorMz, "_mbankID_",mbank_with_mz[idx[2]]$spectrum_id,".pdf"))
    plotSpectraMirror(sps_select[idx[1]], mbank_with_mz[idx[2]], tolerance = 0.2,
                    labels = label_fun, labelPos = 2, labelOffset = 0.2,
                    labelSrt = -30)
    grid()
    dev.off()
  }

  #' get the mbank spectra object.
  if(max(res_l[[i]]) > 0.7) {mbank_best_match <- mbank_with_mz[idx[2]]}

  #' export the scoring matrix & the annotations from massbank
  #'' get mark of massbank
  if(max(res_l[[i]]) > 0.7) {
    sps_final_l[[i]] <- sps_select[idx[1]]
  sps_final_l[[i]]$candidate_source <- "massbank"
  }
  
  #'' export those that have best matched.
  if(max(res_l[[i]]) > 0.7) {
    sps_final_l[[i]]$mbank_candidate_score <- max(res_l[[i]])
    sps_final_l[[i]]$mbank_candidate_mbank_id <- mbank_best_match$spectrum_id
    sps_final_l[[i]]$mbank_candidate_name <- mbank_best_match$compound_name
    sps_final_l[[i]]$mbank_candidate_formula <- mbank_best_match$formula
    sps_final_l[[i]]$mbank_candidate_adduct <- mbank_best_match$adduct
  }

  #'' export all the scoring
  # sps_final_l[[i]]$scoring_mtx_mbank_Id <- names(res_l[[i]][idx[1],])
  # sps_final_l[[i]]$scoring_mtx_score <- as.numeric(res_l[[i]][idx[1],])
  
  library(MsBackendMgf)

  #' Export the spectra to a MGF file
  if(max(res_l[[i]]) > 0.7) {
    print("yes")
    export(sps_final_l[[i]], backend = MsBackendMgf(), file = paste0(output_dir,"mbank_matched_wt_score0.7more_",sps_select[idx[1]]$precursorMz, "_mbankID_",mbank_with_mz[idx[2]]$spectrum_id,".mgf"))
  }
}

  
  
```



```{r massbank-spectra-variables}
#' What variables are available in MassBank
spectraVariables(mbank_with_mz)
```


